package com.zws.jdk.example.binary;

/**
 * @author zws
 * @email 2848392861@qq.com
 * date 2019/1/25
 *
 * 符号扩展
 *   符号扩展用于在数值类型转换时扩展二进制位的长度，
 *   以保证转换后的数值和原数值的符号（正或负）和大小相同，
 *   一般用于较窄的类型（如byte）向较宽的类型（如int）转换。扩展二进制位长度指的是，
 *   在原数值的二进制位左边补齐若干个符号位（0表示正，1表示负）
 *
 * Java类型转换规则（出自《Java解惑》一书）
 *    1、如果最初的数值类型是有符号的，那么就执行符号扩展；
 *    2、char是无符号类型，不管它要被转换成什么类型，都执行零扩展;
 *    3、如果目标类型的长度小于源类型的长度，则直接截取目标类型的长度。例如将int型转换成byte型，直接截取int型的右边8位。
 *
 *
 * 符号类型： 二进制第一位数为1表示负数的类型为符号类型
 *         如Integer类型的二进制第一个数为1是负数所以为符号类型
 *
 * 多重转型
 *   解析"(int)(char)(byte) -1"问题
 *    int(32位) -> byte(8位)
 *    -1是int型的字面量，编码结果为0xffff ffff，即32位全部置1。转换成byte类型时，直接截取最后8位，所以转换后的结果为0xff，对应的十进制值是-1。byte(8位) -> char(16位)
 *    由于byte是有符号类型，所以在转换成char型（16位）时需要进行符号扩展，即在0xff左边连续补上8个1（1是0xff的符号位），结果是0xffff，对应的十进制数是65535(char是无符号类型)。char(16位) -> int(32位)
 *    由于char是无符号类型，转换成int型时进行零扩展，即在0xffff左边连续补上16个0，结果是0x0000 ffff，对应的十进制数是65535
 *
 *   解析 "(int)(char)(b & 0xff)"
 *    0xff是int型字面量（0x0000 00ff），(b & 0xff)的结果是32位的int类型，前24被强制置0，后8位保持不变，
 *    然后转换成char型时，直接截取后16位。这样不管b是正数还是负数，转换成char时，都相当于是在左边补上8个0，即进行零扩展而不是符号扩展。
 *    byte类型(8位)的b扩展成char型(16位)时需要进行符号扩展。
 *
 *
 *
 */
public class ConvertExample {

    public static void main(String[] args) {
        byte b = -1;
        System.out.println((int)(char)b); // 65535
        System.out.println((int)(char)(b & 0xff)); // 255
    }
}


