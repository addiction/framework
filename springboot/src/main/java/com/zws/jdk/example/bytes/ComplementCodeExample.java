package com.zws.jdk.example.bytes;

/**
 * @author zws
 * @email 2848392861@qq.com
 * date 2019/1/21
 *
 * byte类型的表示范围为[-128，+127
 *
 * 十进制方式，直接书写十进制数字
 * 八进制方式，格式以0打头，例如012表示十进制10
 * 十六进制方式，格式为0x打头，例如0xff表示十进制255
 *
 * 在计算机内，有符号数有3种表示法：原码、反码和补码
 *
 * 原码：
 *     原码就是符号位加上真值的绝对值，即用第一个二进制位表示符号（正数该位为0，负数该位为1），其余位表示值。
 *
 * 反码：
 *     正数的反码与其原码相同；
 *     负数的反码是对其原码逐位取反，但符号位除外。
 * 补码：
 *     正数的补码就是其本身；
 *     负数的补码是在其反码的基础上+1
 *
 * 举个例子如下
 *    [+1] = [0000 0001]原 = [0000 0001]反 = [0000 0001]补
 *    [-1] = [1000 0001]原 = [1111 1110]反 = [1111 1111]补
 *
 * 为何要使用补码:
 *    对于计算机而言，加减乘数是最基础的运算, 要设计的尽量简单。
 *    我们知道，根据运算法则，减去一个正数等于加上一个负数，
 *    即：1 - 1 = 1 + (-1) = 0，所以计算机内部可以只有加法而没有减法，
 *    这样计算机的设计就简单了，于是人们开始探索将符号位也参与运算，将减法用加法替代。
 *
 *    1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [1000 0010]原 = -2
 *    1 - 1 = 1 + (-1) = [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0
 *    1 - 1 = 1 + (-1) = [0000 0001]补 + [1111 1111]补 = [0000 0000]补 = [0000 0000]原 = 0
 *    使用原码和反码都不能正确的进行1 - 1的减法运算。
 * 补码的优点：
 *    可将减法变为加法，省去减法器；
 *    无符号数及带符号数的加法运算可以用同一电路完成；
 *    使用补码，修复了原码中0的符号(有 [+0] [-0] 之分)以及存在两个编码(0000 0000 和 1000 0000)的问题，而且还能够多表示一个最低数。
 *
 * 详细： 笔记1。1-java-Java基础-jdk-base-补码
 *
 */
public class ComplementCodeExample {


    public static void main(String[] args) {
        overflow();
    }




    /**
     * 补码表示的溢出问题
     *
     * 同号数相加如果结果的符号位和两加数不同，既是溢出。
     *
     * 例如8bit的byte类型的表示范围为[-128，+127]，那么+128、+129、-129、-130等超出范围的数该怎么表示呢？
     *
     *  超上限 溢出
     * +128 = 127 + 1 = [0111 1111]补 + [0000 0001]补 = [1000 0000]补 = -128
     * +129 = 127 + 2 = [0111 1111]补 + [0000 0010]补 = [1000 0001]补 = [1111 1111]原 = -127
     *
     *  超下限  溢出
     * -129 = -128 + (-1) = [1000 0000]补 + [1111 1111]补 = [0111 1111]补 = 127
     * -130 = -128 + (-2) = [1000 0000]补 + [1111 1110]补 = [0111 1110]补 = 126
     *
     * 通过上述计算我们可以看出，对于8bit的数据(一共2^8 = 256个)：
     * 超上限的数 x = x - 256；
     * 超下限的数 x = x + 256；
     * 下限的相反数与下限相等；
     * 上限的相反数是上限直接取负值。
     *
     */

    public static void overflow(){
        byte a = -128, b = (byte) 128, c = (byte) 129, d = (byte) 130;
        byte e = (byte) -129, f = (byte) -130;
        System.out.println(a == ((byte)-a));    // true
        System.out.println(b);  // -128
        System.out.println(c);  // -127
        System.out.println(d);  // -126
        System.out.println(e);  // 127
        System.out.println(f);  // 126
    }






}
