package com.zws.jdk.example.struct;

/**
 * @author zws
 * @email 2848392861@qq.com
 * date 2019/2/12
 * <p>
 * java 栈
 * 线程私有 栈由一系列帧组成（因此Java栈也叫做帧栈），帧保存一个方法的局部变量、操作数栈、动态连接、方法返回地址、附加信息。每一次方法调用创建一个帧，并压栈。
 * <p>
 * 局部变量表
 * 局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译成Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的。
 * <p>
 * 操作数栈
 *        操作数栈也常被称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也是编译的时候被写入到方法表的Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意Java数据类型，
 * 包括long和double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。栈容量的单位为“字宽”，对于32位虚拟机来说，一个”字宽“占4个字节，对于64位虚拟机来说，一个”字宽“占8个字节。
 *        当一个方法刚刚执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈与出栈操作。
 * 例如，在做算术运算的时候就是通过操作数栈来进行的，又或者调用其它方法的时候是通过操作数栈来行参数传递的。
 * 详见： 笔记1.1-java-java基础-jdk-base-jvm操作数栈
 * <p>
 * 动态连接（常量池指针）
 *         每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。
 * 在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。
 * 这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连
 * 方法返回地址
 *         当一个方法被执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的的方法称为调用者)，
 * 是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法方式称为正常完成出口(Normal Method Invocation Completion)。
 *         另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，
 * 只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口(Abrupt Method Invocation Completion)。
 * 一个方法使用异常完成出口的方式退出，是不会给它的调用都产生任何返回值的。
 *         无论采用何种方式退出，在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。
 * 一般来说，方法正常退出时，调用者PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。
 *         方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压入调用都栈帧的操作数栈中，
 * 调用PC计数器的值以指向方法调用指令后面的一条指令等。
 *  附加信息
 *         虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，
 * 一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。
 * <p>
 * 栈上分配：
 * java虚拟机提供的一种优化技术，基本思想是对于那些线程私有的对象（指的是不可能被其他线程访问的对象），可以将它们打散分配在栈上，而不是分配在堆上。
 * 分配在栈上的好处是可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提供系统的性能。栈上分配的一个技术基础是进行逃逸分析，
 * 逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体。
 *
 * Java对象分配的过程
 *   1。编译器通过逃逸分析，确定对象是在栈上分配还是在堆上分配。如果是在堆上分配，则进入选项2.
 *   2。如果tlab_top + size <= tlab_end，则在在TLAB上直接分配对象并增加tlab_top 的值，如果现有的TLAB不足以存放当前对象则3.
 *   3。重新申请一个TLAB，并再次尝试存放当前对象。如果放不下，则4.
 *   4。在Eden区加锁（这个区是多线程共享的），如果eden_top + size <= eden_end则将对象存放在Eden区，增加eden_top 的值，如果Eden区不足以存放，则5.
 *   5。执行一次Young GC（minor collection）。
 *   进行Young GC：将Eden和在使用的Survivor区中活着的对象复制到另一个Survivor区，并回收Eden和使用着的Survivor区。然后把对象分配到Eden，以后另一个Survivor成为使用的Survivor区；
 *   6。经过Young GC之后，如果Eden区任然不足以存放当前对象，则直接分配到老年代。若老年代剩余空间不够了则进行Full GC，若Full GC后仍不够则抛出OOM异常。

 *
 */
public class StackExample {

    /**
     * 栈上分配
     * <p>
     * 逃逸分析 详见：笔记1.1-java基础-jdk-base-JVM栈分配与TLAB
     * <p>
     * 开启逃逸分析
     * -server -Xmx10m -Xms10m -XX:+DoEscapeAnalysis -Xlog:gc
     * <p>
     * 未开启逃逸分析
     * -server -Xmx10m -Xms10m -XX:-DoEscapeAnalysis -Xlog:gc
     *
     * @param args
     */
    public static void main(String[] args) {
        long b=System.currentTimeMillis();
        for(int i=0;i<100000000;i++){
            alloc();
        }
        long e=System.currentTimeMillis();
        System.out.println(e-b);


    }



    public static void alloc(){
        byte[] b=new byte[2];
        b[0]=1;
    }


}
