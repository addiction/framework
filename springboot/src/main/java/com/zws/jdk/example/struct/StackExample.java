package com.zws.jdk.example.struct;

/**
 * @author zws
 * @email 2848392861@qq.com
 * date 2019/2/12
 *
 * java 栈
 *    线程私有 栈由一系列帧组成（因此Java栈也叫做帧栈），帧保存一个方法的局部变量、操作数栈、动态连接、方法返回地址、附加信息。每一次方法调用创建一个帧，并压栈。
 *
 * 局部变量表
 *   局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译成Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的。
 *
 * 操作数栈
 *   详见： 笔记1.1-java-java基础-jdk-base-jvm操作数栈
 *
 * 动态连接（常量池指针）
 *         每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。
 *    在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。
 *    这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连
 *    方法返回地址
 *         当一个方法被执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的的方法称为调用者)，
 *    是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法方式称为正常完成出口(Normal Method Invocation Completion)。
 *         另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，
 *    只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口(Abrupt Method Invocation Completion)。
 *    一个方法使用异常完成出口的方式退出，是不会给它的调用都产生任何返回值的。
 *         无论采用何种方式退出，在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。
 *     一般来说，方法正常退出时，调用者PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。
 *         方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压入调用都栈帧的操作数栈中，
 *     调用PC计数器的值以指向方法调用指令后面的一条指令等。
 *  附加信息
 *         虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，
 * 一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。
 * <p>
 * 栈上分配：
 * java虚拟机提供的一种优化技术，基本思想是对于那些线程私有的对象（指的是不可能被其他线程访问的对象），可以将它们打散分配在栈上，而不是分配在堆上。
 * 分配在栈上的好处是可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提供系统的性能。栈上分配的一个技术基础是进行逃逸分析，
 * 逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体。
 *
 * Java对象分配的过程： 详见 笔记1.1-java-java基础-jdk-base-JVM 堆及对象分配过程,对象内存布局,对象内存访问的对象分配过程
 *
 *
 */
public class StackExample {

    /**
     * 栈上分配
     * <p>
     * 逃逸分析 详见：笔记1.1-java基础-jdk-base-JVM栈分配与TLAB
     * <p>
     * 开启逃逸分析
     * -server -Xmx10m -Xms10m -XX:+DoEscapeAnalysis -Xlog:gc
     * <p>
     * 未开启逃逸分析
     * -server -Xmx10m -Xms10m -XX:-DoEscapeAnalysis -Xlog:gc
     *
     * @param args
     */
    public static void main(String[] args) {
        long b=System.currentTimeMillis();
        for(int i=0;i<100000000;i++){
            alloc();
        }
        long e=System.currentTimeMillis();
        System.out.println(e-b);


    }



    public static void alloc(){
        byte[] b=new byte[2];
        b[0]=1;
    }


}
